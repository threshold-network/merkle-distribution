schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  tacoOperator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TACoOperator
  tacoOperators(
    skip: Int = 0
    first: Int = 100
    orderBy: TACoOperator_orderBy
    orderDirection: OrderDirection
    where: TACoOperator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TACoOperator!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  stakeData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeData
  stakeDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeData_orderBy
    orderDirection: OrderDirection
    where: StakeData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeData!]!
  stakeHistory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistory
  stakeHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistory_orderBy
    orderDirection: OrderDirection
    where: StakeHistory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeHistory!]!
  appAuthorization(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppAuthorization
  appAuthorizations(
    skip: Int = 0
    first: Int = 100
    orderBy: AppAuthorization_orderBy
    orderDirection: OrderDirection
    where: AppAuthorization_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppAuthorization!]!
  appAuthHistory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppAuthHistory
  appAuthHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: AppAuthHistory_orderBy
    orderDirection: OrderDirection
    where: AppAuthHistory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppAuthHistory!]!
  minStakeAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MinStakeAmount
  minStakeAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: MinStakeAmount_orderBy
    orderDirection: OrderDirection
    where: MinStakeAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MinStakeAmount!]!
  stakeDelegation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeDelegation
  stakeDelegations(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeDelegation_orderBy
    orderDirection: OrderDirection
    where: StakeDelegation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeDelegation!]!
  tokenholderDelegation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenholderDelegation
  tokenholderDelegations(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenholderDelegation_orderBy
    orderDirection: OrderDirection
    where: TokenholderDelegation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenholderDelegation!]!
  daometric(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOMetric
  daometrics(
    skip: Int = 0
    first: Int = 100
    orderBy: DAOMetric_orderBy
    orderDirection: OrderDirection
    where: DAOMetric_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAOMetric!]!
  tacoCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TACoCommitment
  tacoCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: TACoCommitment_orderBy
    orderDirection: OrderDirection
    where: TACoCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TACoCommitment!]!
  delegation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegation
  delegations(
    skip: Int = 0
    first: Int = 100
    orderBy: Delegation_orderBy
    orderDirection: OrderDirection
    where: Delegation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegation!]!
  simplePREApplication(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SimplePREApplication
  simplePREApplications(
    skip: Int = 0
    first: Int = 100
    orderBy: SimplePREApplication_orderBy
    orderDirection: OrderDirection
    where: SimplePREApplication_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SimplePREApplication!]!
}

type Subscription {
  tacoOperator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TACoOperator
  tacoOperators(
    skip: Int = 0
    first: Int = 100
    orderBy: TACoOperator_orderBy
    orderDirection: OrderDirection
    where: TACoOperator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TACoOperator!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
  account(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  stakeData(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeData
  stakeDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeData_orderBy
    orderDirection: OrderDirection
    where: StakeData_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeData!]!
  stakeHistory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeHistory
  stakeHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeHistory_orderBy
    orderDirection: OrderDirection
    where: StakeHistory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeHistory!]!
  appAuthorization(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppAuthorization
  appAuthorizations(
    skip: Int = 0
    first: Int = 100
    orderBy: AppAuthorization_orderBy
    orderDirection: OrderDirection
    where: AppAuthorization_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppAuthorization!]!
  appAuthHistory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppAuthHistory
  appAuthHistories(
    skip: Int = 0
    first: Int = 100
    orderBy: AppAuthHistory_orderBy
    orderDirection: OrderDirection
    where: AppAuthHistory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppAuthHistory!]!
  minStakeAmount(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MinStakeAmount
  minStakeAmounts(
    skip: Int = 0
    first: Int = 100
    orderBy: MinStakeAmount_orderBy
    orderDirection: OrderDirection
    where: MinStakeAmount_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MinStakeAmount!]!
  stakeDelegation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StakeDelegation
  stakeDelegations(
    skip: Int = 0
    first: Int = 100
    orderBy: StakeDelegation_orderBy
    orderDirection: OrderDirection
    where: StakeDelegation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StakeDelegation!]!
  tokenholderDelegation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenholderDelegation
  tokenholderDelegations(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenholderDelegation_orderBy
    orderDirection: OrderDirection
    where: TokenholderDelegation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenholderDelegation!]!
  daometric(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DAOMetric
  daometrics(
    skip: Int = 0
    first: Int = 100
    orderBy: DAOMetric_orderBy
    orderDirection: OrderDirection
    where: DAOMetric_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DAOMetric!]!
  tacoCommitment(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TACoCommitment
  tacoCommitments(
    skip: Int = 0
    first: Int = 100
    orderBy: TACoCommitment_orderBy
    orderDirection: OrderDirection
    where: TACoCommitment_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TACoCommitment!]!
  delegation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegation
  delegations(
    skip: Int = 0
    first: Int = 100
    orderBy: Delegation_orderBy
    orderDirection: OrderDirection
    where: Delegation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegation!]!
  simplePREApplication(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SimplePREApplication
  simplePREApplications(
    skip: Int = 0
    first: Int = 100
    orderBy: SimplePREApplication_orderBy
    orderDirection: OrderDirection
    where: SimplePREApplication_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SimplePREApplication!]!
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

"""
8 bytes signed integer

"""
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

"""TACoOperator represents the TACo operator's info of a staking provider"""
type TACoOperator {
  """ID is the staking provider address"""
  id: ID!
  """Operator's address"""
  operator: Bytes!
  """
  Timestamp in which the current operator was confirmed to the staking provider
  """
  confirmedTimestamp: BigInt!
  """
  Timestamp in which the first operator of this staking provider was confirmed
  """
  confirmedTimestampFirstOperator: BigInt
  """The operator won't be confirmed during the operator address update"""
  confirmed: Boolean
  """
  Timestamp in which the current operator was bonded to the staking provider
  """
  bondedTimestamp: BigInt!
  """
  Timestamp in which the first operator of this staking provider was bonded
  """
  bondedTimestampFirstOperator: BigInt
}

input TACoOperator_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  operator: Bytes
  operator_not: Bytes
  operator_gt: Bytes
  operator_lt: Bytes
  operator_gte: Bytes
  operator_lte: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  confirmedTimestamp: BigInt
  confirmedTimestamp_not: BigInt
  confirmedTimestamp_gt: BigInt
  confirmedTimestamp_lt: BigInt
  confirmedTimestamp_gte: BigInt
  confirmedTimestamp_lte: BigInt
  confirmedTimestamp_in: [BigInt!]
  confirmedTimestamp_not_in: [BigInt!]
  confirmedTimestampFirstOperator: BigInt
  confirmedTimestampFirstOperator_not: BigInt
  confirmedTimestampFirstOperator_gt: BigInt
  confirmedTimestampFirstOperator_lt: BigInt
  confirmedTimestampFirstOperator_gte: BigInt
  confirmedTimestampFirstOperator_lte: BigInt
  confirmedTimestampFirstOperator_in: [BigInt!]
  confirmedTimestampFirstOperator_not_in: [BigInt!]
  confirmed: Boolean
  confirmed_not: Boolean
  confirmed_in: [Boolean!]
  confirmed_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TACoOperator_filter]
  or: [TACoOperator_filter]
  bondedTimestamp: BigInt
  bondedTimestamp_not: BigInt
  bondedTimestamp_gt: BigInt
  bondedTimestamp_lt: BigInt
  bondedTimestamp_gte: BigInt
  bondedTimestamp_lte: BigInt
  bondedTimestamp_in: [BigInt!]
  bondedTimestamp_not_in: [BigInt!]
  bondedTimestampFirstOperator: BigInt
  bondedTimestampFirstOperator_not: BigInt
  bondedTimestampFirstOperator_gt: BigInt
  bondedTimestampFirstOperator_lt: BigInt
  bondedTimestampFirstOperator_gte: BigInt
  bondedTimestampFirstOperator_lte: BigInt
  bondedTimestampFirstOperator_in: [BigInt!]
  bondedTimestampFirstOperator_not_in: [BigInt!]
}

enum TACoOperator_orderBy {
  id
  operator
  confirmedTimestamp
  confirmedTimestampFirstOperator
  confirmed
  bondedTimestamp
  bondedTimestampFirstOperator
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

"""Account represents the base user data: user's stakes and delegations"""
type Account {
  """ID is the account's ETH address"""
  id: ID!
  stakes(skip: Int = 0, first: Int = 100, orderBy: StakeData_orderBy, orderDirection: OrderDirection, where: StakeData_filter): [StakeData!]
  delegatee: TokenholderDelegation
}

input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stakes_: StakeData_filter
  delegatee: String
  delegatee_not: String
  delegatee_gt: String
  delegatee_lt: String
  delegatee_gte: String
  delegatee_lte: String
  delegatee_in: [String!]
  delegatee_not_in: [String!]
  delegatee_contains: String
  delegatee_contains_nocase: String
  delegatee_not_contains: String
  delegatee_not_contains_nocase: String
  delegatee_starts_with: String
  delegatee_starts_with_nocase: String
  delegatee_not_starts_with: String
  delegatee_not_starts_with_nocase: String
  delegatee_ends_with: String
  delegatee_ends_with_nocase: String
  delegatee_not_ends_with: String
  delegatee_not_ends_with_nocase: String
  delegatee_: TokenholderDelegation_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  or: [Account_filter]
}

enum Account_orderBy {
  id
  stakes
  delegatee
  delegatee__id
  delegatee__totalWeight
  delegatee__liquidWeight
}

"""AppAuthHistory stores each change in the stake's authorization of apps"""
type AppAuthHistory {
  """ID is <staking provider address>-<application address>-<block number>"""
  id: ID!
  """AppAuthorization of this update in the authorization"""
  appAuthorization: AppAuthorization!
  """
  Amount of total T authorized by staking provider to the application in this block
  """
  amount: BigInt!
  """Amount of T that has been increased or decreased"""
  eventAmount: BigInt!
  """Type of event that caused this update"""
  eventType: String!
  """Block in which this authorization update became effective"""
  blockNumber: BigInt!
  """Timestamp in which this authorization update became effective"""
  timestamp: BigInt!
}

input AppAuthHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  appAuthorization: String
  appAuthorization_not: String
  appAuthorization_gt: String
  appAuthorization_lt: String
  appAuthorization_gte: String
  appAuthorization_lte: String
  appAuthorization_in: [String!]
  appAuthorization_not_in: [String!]
  appAuthorization_contains: String
  appAuthorization_contains_nocase: String
  appAuthorization_not_contains: String
  appAuthorization_not_contains_nocase: String
  appAuthorization_starts_with: String
  appAuthorization_starts_with_nocase: String
  appAuthorization_not_starts_with: String
  appAuthorization_not_starts_with_nocase: String
  appAuthorization_ends_with: String
  appAuthorization_ends_with_nocase: String
  appAuthorization_not_ends_with: String
  appAuthorization_not_ends_with_nocase: String
  appAuthorization_: AppAuthorization_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  eventAmount: BigInt
  eventAmount_not: BigInt
  eventAmount_gt: BigInt
  eventAmount_lt: BigInt
  eventAmount_gte: BigInt
  eventAmount_lte: BigInt
  eventAmount_in: [BigInt!]
  eventAmount_not_in: [BigInt!]
  eventType: String
  eventType_not: String
  eventType_gt: String
  eventType_lt: String
  eventType_gte: String
  eventType_lte: String
  eventType_in: [String!]
  eventType_not_in: [String!]
  eventType_contains: String
  eventType_contains_nocase: String
  eventType_not_contains: String
  eventType_not_contains_nocase: String
  eventType_starts_with: String
  eventType_starts_with_nocase: String
  eventType_not_starts_with: String
  eventType_not_starts_with_nocase: String
  eventType_ends_with: String
  eventType_ends_with_nocase: String
  eventType_not_ends_with: String
  eventType_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AppAuthHistory_filter]
  or: [AppAuthHistory_filter]
}

enum AppAuthHistory_orderBy {
  id
  appAuthorization
  appAuthorization__id
  appAuthorization__appAddress
  appAuthorization__amount
  appAuthorization__amountDeauthorizing
  appAuthorization__appName
  amount
  eventAmount
  eventType
  blockNumber
  timestamp
}

"""
AppAuthorizations represents the stake authorizations to Threshold apps
"""
type AppAuthorization {
  """ID is <staking provider address>-<application address>"""
  id: ID!
  """Application contract address"""
  appAddress: Bytes!
  """Stake data of the staking provider"""
  stake: StakeData!
  """Amount of total T currently authorized to the application"""
  amount: BigInt!
  """Amount of T that is being deauthorized"""
  amountDeauthorizing: BigInt!
  """Application name (if known)"""
  appName: String
}

input AppAuthorization_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  appAddress: Bytes
  appAddress_not: Bytes
  appAddress_gt: Bytes
  appAddress_lt: Bytes
  appAddress_gte: Bytes
  appAddress_lte: Bytes
  appAddress_in: [Bytes!]
  appAddress_not_in: [Bytes!]
  appAddress_contains: Bytes
  appAddress_not_contains: Bytes
  stake: String
  stake_not: String
  stake_gt: String
  stake_lt: String
  stake_gte: String
  stake_lte: String
  stake_in: [String!]
  stake_not_in: [String!]
  stake_contains: String
  stake_contains_nocase: String
  stake_not_contains: String
  stake_not_contains_nocase: String
  stake_starts_with: String
  stake_starts_with_nocase: String
  stake_not_starts_with: String
  stake_not_starts_with_nocase: String
  stake_ends_with: String
  stake_ends_with_nocase: String
  stake_not_ends_with: String
  stake_not_ends_with_nocase: String
  stake_: StakeData_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  amountDeauthorizing: BigInt
  amountDeauthorizing_not: BigInt
  amountDeauthorizing_gt: BigInt
  amountDeauthorizing_lt: BigInt
  amountDeauthorizing_gte: BigInt
  amountDeauthorizing_lte: BigInt
  amountDeauthorizing_in: [BigInt!]
  amountDeauthorizing_not_in: [BigInt!]
  appName: String
  appName_not: String
  appName_gt: String
  appName_lt: String
  appName_gte: String
  appName_lte: String
  appName_in: [String!]
  appName_not_in: [String!]
  appName_contains: String
  appName_contains_nocase: String
  appName_not_contains: String
  appName_not_contains_nocase: String
  appName_starts_with: String
  appName_starts_with_nocase: String
  appName_not_starts_with: String
  appName_not_starts_with_nocase: String
  appName_ends_with: String
  appName_ends_with_nocase: String
  appName_not_ends_with: String
  appName_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AppAuthorization_filter]
  or: [AppAuthorization_filter]
}

enum AppAuthorization_orderBy {
  id
  appAddress
  stake
  stake__id
  stake__beneficiary
  stake__authorizer
  stake__stakedAmount
  amount
  amountDeauthorizing
  appName
}

"""
DAOMetric represents the liquid and staked T tokens in Threshold Network DAO
"""
type DAOMetric {
  """ID is 'dao-metrics' (singleton entity)"""
  id: ID!
  liquidTotal: BigInt!
  stakedTotal: BigInt!
}

input DAOMetric_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  liquidTotal: BigInt
  liquidTotal_not: BigInt
  liquidTotal_gt: BigInt
  liquidTotal_lt: BigInt
  liquidTotal_gte: BigInt
  liquidTotal_lte: BigInt
  liquidTotal_in: [BigInt!]
  liquidTotal_not_in: [BigInt!]
  stakedTotal: BigInt
  stakedTotal_not: BigInt
  stakedTotal_gt: BigInt
  stakedTotal_lt: BigInt
  stakedTotal_gte: BigInt
  stakedTotal_lte: BigInt
  stakedTotal_in: [BigInt!]
  stakedTotal_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DAOMetric_filter]
  or: [DAOMetric_filter]
}

enum DAOMetric_orderBy {
  id
  liquidTotal
  stakedTotal
}

interface Delegation {
  """The delegatee address"""
  id: ID!
  totalWeight: BigInt!
}

input Delegation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalWeight: BigInt
  totalWeight_not: BigInt
  totalWeight_gt: BigInt
  totalWeight_lt: BigInt
  totalWeight_gte: BigInt
  totalWeight_lte: BigInt
  totalWeight_in: [BigInt!]
  totalWeight_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Delegation_filter]
  or: [Delegation_filter]
}

enum Delegation_orderBy {
  id
  totalWeight
}

"""MinStakeAmount represents the minimum amount of tokens to stake"""
type MinStakeAmount {
  """ID is min-stake + transaction hash in which the amount changed"""
  id: ID!
  amount: BigInt!
  updatedAt: BigInt!
  blockNumber: BigInt!
}

input MinStakeAmount_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  updatedAt: BigInt
  updatedAt_not: BigInt
  updatedAt_gt: BigInt
  updatedAt_lt: BigInt
  updatedAt_gte: BigInt
  updatedAt_lte: BigInt
  updatedAt_in: [BigInt!]
  updatedAt_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MinStakeAmount_filter]
  or: [MinStakeAmount_filter]
}

enum MinStakeAmount_orderBy {
  id
  amount
  updatedAt
  blockNumber
}

"""StakeData represents the information about each stake"""
type StakeData {
  """ID is the staking provider's ETH address"""
  id: ID!
  owner: Account!
  beneficiary: Bytes!
  authorizer: Bytes!
  """Staked T token total amount"""
  stakedAmount: BigInt!
  delegatee: StakeDelegation
  stakeHistory(skip: Int = 0, first: Int = 100, orderBy: StakeHistory_orderBy, orderDirection: OrderDirection, where: StakeHistory_filter): [StakeHistory!]
  authorizations(skip: Int = 0, first: Int = 100, orderBy: AppAuthorization_orderBy, orderDirection: OrderDirection, where: AppAuthorization_filter): [AppAuthorization!]
}

input StakeData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Account_filter
  beneficiary: Bytes
  beneficiary_not: Bytes
  beneficiary_gt: Bytes
  beneficiary_lt: Bytes
  beneficiary_gte: Bytes
  beneficiary_lte: Bytes
  beneficiary_in: [Bytes!]
  beneficiary_not_in: [Bytes!]
  beneficiary_contains: Bytes
  beneficiary_not_contains: Bytes
  authorizer: Bytes
  authorizer_not: Bytes
  authorizer_gt: Bytes
  authorizer_lt: Bytes
  authorizer_gte: Bytes
  authorizer_lte: Bytes
  authorizer_in: [Bytes!]
  authorizer_not_in: [Bytes!]
  authorizer_contains: Bytes
  authorizer_not_contains: Bytes
  stakedAmount: BigInt
  stakedAmount_not: BigInt
  stakedAmount_gt: BigInt
  stakedAmount_lt: BigInt
  stakedAmount_gte: BigInt
  stakedAmount_lte: BigInt
  stakedAmount_in: [BigInt!]
  stakedAmount_not_in: [BigInt!]
  delegatee: String
  delegatee_not: String
  delegatee_gt: String
  delegatee_lt: String
  delegatee_gte: String
  delegatee_lte: String
  delegatee_in: [String!]
  delegatee_not_in: [String!]
  delegatee_contains: String
  delegatee_contains_nocase: String
  delegatee_not_contains: String
  delegatee_not_contains_nocase: String
  delegatee_starts_with: String
  delegatee_starts_with_nocase: String
  delegatee_not_starts_with: String
  delegatee_not_starts_with_nocase: String
  delegatee_ends_with: String
  delegatee_ends_with_nocase: String
  delegatee_not_ends_with: String
  delegatee_not_ends_with_nocase: String
  delegatee_: StakeDelegation_filter
  stakeHistory_: StakeHistory_filter
  authorizations_: AppAuthorization_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeData_filter]
  or: [StakeData_filter]
}

enum StakeData_orderBy {
  id
  owner
  owner__id
  beneficiary
  authorizer
  stakedAmount
  delegatee
  delegatee__id
  delegatee__totalWeight
  stakeHistory
  authorizations
}

"""
StakeDelegation represents the delegatee to whom the Stake DAO voting power has been delegated
"""
type StakeDelegation implements Delegation {
  """ID is delegatee ETH address"""
  id: ID!
  """Stakes in the T network, tracked by T staking contract"""
  totalWeight: BigInt!
  stakeDelegators(skip: Int = 0, first: Int = 100, orderBy: StakeData_orderBy, orderDirection: OrderDirection, where: StakeData_filter): [StakeData!]
}

input StakeDelegation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalWeight: BigInt
  totalWeight_not: BigInt
  totalWeight_gt: BigInt
  totalWeight_lt: BigInt
  totalWeight_gte: BigInt
  totalWeight_lte: BigInt
  totalWeight_in: [BigInt!]
  totalWeight_not_in: [BigInt!]
  stakeDelegators_: StakeData_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeDelegation_filter]
  or: [StakeDelegation_filter]
}

enum StakeDelegation_orderBy {
  id
  totalWeight
  stakeDelegators
}

"""History of each stake"""
type StakeHistory {
  """ID is <staking provider address>-<block number>"""
  id: ID!
  """Stake data of the staking provider"""
  stake: StakeData!
  """The amount that has been added or reduced"""
  eventAmount: BigInt!
  """The total staked amount at this time"""
  stakedAmount: BigInt!
  """The event that updated the staked amount: Staked, ToppedUp or Unstaked"""
  eventType: String!
  """The Ethereum block number in which the stake was updated"""
  blockNumber: BigInt!
  """The timestamp in which the stake was updated"""
  timestamp: BigInt!
}

input StakeHistory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stake: String
  stake_not: String
  stake_gt: String
  stake_lt: String
  stake_gte: String
  stake_lte: String
  stake_in: [String!]
  stake_not_in: [String!]
  stake_contains: String
  stake_contains_nocase: String
  stake_not_contains: String
  stake_not_contains_nocase: String
  stake_starts_with: String
  stake_starts_with_nocase: String
  stake_not_starts_with: String
  stake_not_starts_with_nocase: String
  stake_ends_with: String
  stake_ends_with_nocase: String
  stake_not_ends_with: String
  stake_not_ends_with_nocase: String
  stake_: StakeData_filter
  eventAmount: BigInt
  eventAmount_not: BigInt
  eventAmount_gt: BigInt
  eventAmount_lt: BigInt
  eventAmount_gte: BigInt
  eventAmount_lte: BigInt
  eventAmount_in: [BigInt!]
  eventAmount_not_in: [BigInt!]
  stakedAmount: BigInt
  stakedAmount_not: BigInt
  stakedAmount_gt: BigInt
  stakedAmount_lt: BigInt
  stakedAmount_gte: BigInt
  stakedAmount_lte: BigInt
  stakedAmount_in: [BigInt!]
  stakedAmount_not_in: [BigInt!]
  eventType: String
  eventType_not: String
  eventType_gt: String
  eventType_lt: String
  eventType_gte: String
  eventType_lte: String
  eventType_in: [String!]
  eventType_not_in: [String!]
  eventType_contains: String
  eventType_contains_nocase: String
  eventType_not_contains: String
  eventType_not_contains_nocase: String
  eventType_starts_with: String
  eventType_starts_with_nocase: String
  eventType_not_starts_with: String
  eventType_not_starts_with_nocase: String
  eventType_ends_with: String
  eventType_ends_with_nocase: String
  eventType_not_ends_with: String
  eventType_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StakeHistory_filter]
  or: [StakeHistory_filter]
}

enum StakeHistory_orderBy {
  id
  stake
  stake__id
  stake__beneficiary
  stake__authorizer
  stake__stakedAmount
  eventAmount
  stakedAmount
  eventType
  blockNumber
  timestamp
}

"""TACo commitments made by a staking provider"""
type TACoCommitment {
  """ID is the staking provider address"""
  id: ID!
  """Timestamp of the end of the lock-up"""
  endCommitment: BigInt!
  """Selected duration in month of the lock-up"""
  duration: Int!
}

input TACoCommitment_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  endCommitment: BigInt
  endCommitment_not: BigInt
  endCommitment_gt: BigInt
  endCommitment_lt: BigInt
  endCommitment_gte: BigInt
  endCommitment_lte: BigInt
  endCommitment_in: [BigInt!]
  endCommitment_not_in: [BigInt!]
  duration: Int
  duration_not: Int
  duration_gt: Int
  duration_lt: Int
  duration_gte: Int
  duration_lte: Int
  duration_in: [Int!]
  duration_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TACoCommitment_filter]
  or: [TACoCommitment_filter]
}

enum TACoCommitment_orderBy {
  id
  endCommitment
  duration
}

"""
TokenholderDelegation represents the delegatee to whom the TokenHolder DAO voting power has been delegated
"""
type TokenholderDelegation implements Delegation {
  """ID is delegatee ETH address"""
  id: ID!
  """
  Liquid T plus staked T in the T network. Legacy stakes (NU/KEEP) count for tokenholders' voting power, but not for the total voting power of the Tokenholder DAO (as it's already accounted by the Vending Machines)
  """
  totalWeight: BigInt!
  """Liquid T, tracked by the T Token contract"""
  liquidWeight: BigInt!
  delegators(skip: Int = 0, first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, where: Account_filter): [Account!]
}

input TokenholderDelegation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalWeight: BigInt
  totalWeight_not: BigInt
  totalWeight_gt: BigInt
  totalWeight_lt: BigInt
  totalWeight_gte: BigInt
  totalWeight_lte: BigInt
  totalWeight_in: [BigInt!]
  totalWeight_not_in: [BigInt!]
  liquidWeight: BigInt
  liquidWeight_not: BigInt
  liquidWeight_gt: BigInt
  liquidWeight_lt: BigInt
  liquidWeight_gte: BigInt
  liquidWeight_lte: BigInt
  liquidWeight_in: [BigInt!]
  liquidWeight_not_in: [BigInt!]
  delegators_: Account_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenholderDelegation_filter]
  or: [TokenholderDelegation_filter]
}

enum TokenholderDelegation_orderBy {
  id
  totalWeight
  liquidWeight
  delegators
}

"""
SimplePREApplication represents the state of Simple Proxy ReEncryption operators
"""
type SimplePREApplication {
  """ID is the staking provider ETH address"""
  id: ID!
  """Operator's ETH address"""
  operator: Bytes!
  """Stake address related to this PRE operator"""
  stake: Bytes!
  """
  UNIX timestamp in which an operator was bonded for this staking provider for first time
  """
  bondedTimestamp: BigInt
  """
  UNIX timestamp in which an operator was confirmed for this staking provider for first time
  """
  confirmedTimestamp: BigInt
}

input SimplePREApplication_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  operator: Bytes
  operator_not: Bytes
  operator_gt: Bytes
  operator_lt: Bytes
  operator_gte: Bytes
  operator_lte: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  stake: Bytes
  stake_not: Bytes
  stake_gt: Bytes
  stake_lt: Bytes
  stake_gte: Bytes
  stake_lte: Bytes
  stake_in: [Bytes!]
  stake_not_in: [Bytes!]
  stake_contains: Bytes
  stake_not_contains: Bytes
  bondedTimestamp: BigInt
  bondedTimestamp_not: BigInt
  bondedTimestamp_gt: BigInt
  bondedTimestamp_lt: BigInt
  bondedTimestamp_gte: BigInt
  bondedTimestamp_lte: BigInt
  bondedTimestamp_in: [BigInt!]
  bondedTimestamp_not_in: [BigInt!]
  confirmedTimestamp: BigInt
  confirmedTimestamp_not: BigInt
  confirmedTimestamp_gt: BigInt
  confirmedTimestamp_lt: BigInt
  confirmedTimestamp_gte: BigInt
  confirmedTimestamp_lte: BigInt
  confirmedTimestamp_in: [BigInt!]
  confirmedTimestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SimplePREApplication_filter]
  or: [SimplePREApplication_filter]
}

enum SimplePREApplication_orderBy {
  id
  operator
  stake
  bondedTimestamp
  confirmedTimestamp
}